import {
  BeatConfig, BeatDetection, BeatFeatures,
  PeakAnalysis, BeatMorphology, BeatQuality,
  TemplateMatching, BeatValidation, BeatMetrics,
  IntervalAnalysis, BeatClassification, BeatSegmentation,
  AdaptiveThreshold, PeakEnhancement
} from '@/types';

/**
 * Detector avanzado de latidos cardíacos
 * Implementa técnicas de última generación en detección PPG
 * @version 2.0.0
 */
export class BeatDetector {
  // Configuración optimizada
  private readonly config: BeatConfig = {
    sampleRate: 30,           // Hz
    windowSize: 128,          // Muestras
    
    // Detección de picos
    peak: {
      method: 'adaptive',     // Detección adaptativa
      enhancement: {
        enabled: true,        // Mejora de picos
        window: 7,           // Ventana de mejora
        order: 2             // Orden polinomial
      },
      threshold: {
        initial: 0.5,        // Umbral inicial
        adaptation: 0.1,     // Tasa de adaptación
        minValue: 0.2,       // Valor mínimo
        maxValue: 0.8        // Valor máximo
      }
    },

    // Análisis de latidos
    beat: {
      minInterval: 0.4,      // Segundos
      maxInterval: 2.0,      // Segundos
      template: {
        size: 32,            // Muestras
        count: 8,            // Plantillas
        update: 'selective'  // Actualización
      },
      morphology: {
        features: [
          'width',           // Ancho
          'amplitude',       // Amplitud
          'slope',           // Pendiente
          'area',            // Área
          'symmetry'         // Simetría
        ],
        normalization: true  // Normalización
      }
    },

    // Validación
    validation: {
      minQuality: 0.7,       // Calidad mínima
      maxVariability: 0.3,   // Variabilidad máxima
      physiological: {
        minRate: 40,         // BPM
        maxRate: 220,        // BPM
        maxChange: 15        // BPM/s
      }
    },

    // Optimizaciones
    optimization: {
      vectorization: true,   // SIMD
      parallelization: true, // Multi-hilo
      precision: 'double',   // Precisión
      cacheSize: 10,        // Tamaño de cache
      adaptiveWindow: true   // Ventana adaptativa
    }
  };

  // Procesadores especializados
  private readonly peakDetector: PeakEnhancement;
  private readonly templateMatcher: TemplateMatching;
  private readonly morphologyAnalyzer: BeatMorphology;
  private readonly beatValidator: BeatValidation;

  // Buffers optimizados
  private readonly buffers = {
    signal: new Float64Array(256),
    peaks: new Float64Array(32),
    templates: new Float64Array(8 * 32),
    features: new Float64Array(64),
    intervals: new Float64Array(32)
  };

  // Estado del detector
  private readonly state = {
    lastBeat: null as BeatDetection | null,
    beatHistory: [] as BeatDetection[],
    templateHistory: [] as Float64Array[],
    qualityHistory: [] as number[],
    threshold: {
      value: 0.5,
      history: [] as number[]
    },
    adaptation: {
      window: 128,
      overlap: 64,
      factor: 0.1
    }
  };

  constructor() {
    this.initializeDetector();
  }

  /**
   * Detección principal de latidos
   * Implementa pipeline completo de detección
   */
  public detect(signal: Float64Array): BeatDetection {
    try {
      // 1. Validación de señal
      if (!this.validateSignal(signal)) {
        throw new Error('Invalid signal for beat detection');
      }

      // 2. Mejora de señal
      const enhanced = this.enhanceSignal(signal);

      // 3. Detección de picos
      const peaks = this.detectPeaks(enhanced);

      // 4. Análisis de latidos
      const beats = this.analyzeBeats(peaks);

      // 5. Validación de latidos
      const validated = this.validateBeats(beats);

      // 6. Clasificación de latidos
      const classified = this.classifyBeats(validated);

      // 7. Extracción de características
      const features = this.extractFeatures(classified);

      // 8. Análisis de calidad
      const quality = this.analyzeQuality({
        beats: classified,
        features,
        signal: enhanced
      });

      // 9. Actualización de estado
      this.updateState({
        beats: classified,
        features,
        quality
      });

      return {
        beats: classified,
        features,
        quality,
        metrics: this.calculateMetrics(classified)
      };

    } catch (error) {
      console.error('Error in beat detection:', error);
      return this.handleDetectionError(error);
    }
  }

  /**
   * Mejora de señal para detección
   */
  private enhanceSignal(signal: Float64Array): Float64Array {
    if (!this.config.peak.enhancement.enabled) {
      return signal;
    }

    // 1. Preparación de ventana
    const window = this.config.peak.enhancement.window;
    const enhanced = new Float64Array(signal.length);

    // 2. Mejora polinomial
    for (let i = window; i < signal.length - window; i++) {
      const coefficients = this.fitPolynomial(
        signal.subarray(i - window, i + window + 1),
        this.config.peak.enhancement.order
      );

      enhanced[i] = this.evaluatePolynomial(
        coefficients,
        window
      );
    }

    // 3. Manejo de bordes
    this.handleSignalBoundaries(
      signal,
      enhanced,
      window
    );

    return enhanced;
  }

  /**
   * Detección adaptativa de picos
   */
  private detectPeaks(signal: Float64Array): number[] {
    const peaks: number[] = [];
    const threshold = this.state.threshold.value;

    // 1. Búsqueda de picos
    for (let i = 1; i < signal.length - 1; i++) {
      if (this.isPeak(signal, i, threshold)) {
        peaks.push(i);
      }
    }

    // 2. Refinamiento de picos
    const refined = this.refinePeaks(
      signal,
      peaks
    );

    // 3. Validación de intervalos
    const validated = this.validateIntervals(
      refined,
      this.config.beat.minInterval * this.config.sampleRate,
      this.config.beat.maxInterval * this.config.sampleRate
    );

    // 4. Actualización de umbral
    this.updateThreshold(
      signal,
      validated
    );

    return validated;
  }

  /**
   * Análisis morfológico de latidos
   */
  private analyzeBeats(peaks: number[]): BeatFeatures[] {
    return peaks.map(peak => {
      // 1. Segmentación de latido
      const segment = this.segmentBeat(
        this.buffers.signal,
        peak,
        this.config.beat.template.size
      );

      // 2. Análisis morfológico
      const morphology = this.analyzeMorphology(segment);

      // 3. Comparación con plantillas
      const template = this.matchTemplate(segment);

      // 4. Características del latido
      return {
        peak,
        segment,
        morphology,
        template,
        interval: this.calculateInterval(peak),
        quality: this.calculateBeatQuality(morphology)
      };
    });
  }

  /**
   * Optimizaciones de bajo nivel
   */
  private updateThreshold(
    signal: Float64Array,
    peaks: number[]
  ): void {
    if (peaks.length === 0) {
      return;
    }

    // 1. Cálculo de amplitudes
    const amplitudes = peaks.map(peak => signal[peak]);

    // 2. Actualización adaptativa
    const meanAmplitude = amplitudes.reduce((a, b) => a + b) / amplitudes.length;
    const adaptation = this.config.peak.threshold.adaptation;

    this.state.threshold.value += adaptation * (
      meanAmplitude * 0.6 - this.state.threshold.value
    );

    // 3. Limitación de umbral
    this.state.threshold.value = Math.max(
      this.config.peak.threshold.minValue,
      Math.min(
        this.config.peak.threshold.maxValue,
        this.state.threshold.value
      )
    );

    // 4. Actualización de historial
    this.state.threshold.history.push(this.state.threshold.value);
    if (this.state.threshold.history.length > 100) {
      this.state.threshold.history.shift();
    }
  }

  /**
   * Gestión de estado
   */
  private updateState(data: {
    beats: BeatFeatures[];
    features: BeatMetrics;
    quality: BeatQuality;
  }): void {
    // 1. Actualización de último latido
    if (data.beats.length > 0) {
      this.state.lastBeat = data.beats[data.beats.length - 1];
    }

    // 2. Actualización de historiales
    this.state.beatHistory.push(...data.beats);
    this.state.qualityHistory.push(data.quality.overall);

    // 3. Mantenimiento de historiales
    if (this.state.beatHistory.length > 30) {
      this.state.beatHistory = this.state.beatHistory.slice(-30);
      this.state.qualityHistory = this.state.qualityHistory.slice(-30);
    }

    // 4. Actualización de plantillas
    if (data.quality.overall > this.config.validation.minQuality) {
      this.updateTemplates(data.beats);
    }
  }

  /**
   * Gestión de recursos
   */
  public dispose(): void {
    try {
      // 1. Limpieza de procesadores
      this.peakDetector.dispose();
      this.templateMatcher.dispose();
      this.morphologyAnalyzer.dispose();
      this.beatValidator.dispose();

      // 2. Limpieza de buffers
      Object.values(this.buffers).forEach(buffer => {
        buffer.fill(0);
      });

      // 3. Limpieza de estado
      this.state.lastBeat = null;
      this.state.beatHistory = [];
      this.state.templateHistory = [];
      this.state.qualityHistory = [];
      this.state.threshold = {
        value: this.config.peak.threshold.initial,
        history: []
      };
      this.state.adaptation = {
        window: 128,
        overlap: 64,
        factor: 0.1
      };

    } catch (error) {
      console.error('Error in dispose:', error);
    }
  }
}
